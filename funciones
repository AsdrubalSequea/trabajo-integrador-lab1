#include <iostream>
#include <stdlib.h>
#include <locale>
#include <time.h>
#include "funciones.h"

using namespace std;

const int TIPOS_CARTAS = 5, PALOS = 4, CARTAS_POR_MANO = 5;
void inicioPartida(int &maximaPuntuacion, string &maximoGanador, string &jugador_1, string &jugador_2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], int CARTAS_POR_MANO);

void estadisticas(int maximaPuntuacion, string ganador);

void creditos();

int tirada_de_dados(string);

void preparacion_barajas(string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS]);

void repatir_cartas(string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], string []);

string quien_inicia(string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[]);

void iniciador_cartas_bloqueadas(bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[]);

void acciones_del_dado(int dado, string turno, string jugador1, string jugador2, string corralJugador1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], bool &jugador_1_paso_turno, bool &jugador_2_paso_turno, bool &le_robaron_al_1, bool &le_robaron_al_2);

void accion_1(string turno, string corral_propio[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas[]);

void accion_2(string turno, string corral_contrario[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador[]);

void accion_3(string turno, string corral_propio[], string corral_contrario[], bool cartas_bloqueadas_contrario[], bool cartas_bloqueadas_propias[], bool &le_robaron);

void accion_4(string turno, string corral_propio[]);

void accion_5(string turno, string corral_propio[], bool cartas_bloqueadas[]);

void accion_6(string turno, string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], bool &jugador_1_paso_turno, bool &jugador_2_paso_turno, bool &le_robaron_al_1, bool &le_robaron_al_2);

int verificador_de_indices();

void verificador_de_orden(string jugador_1, string jugador_2, string corraljugador_1[], string corraljugador_2[], int CARTAS_POR_MANO, string &ganador, bool &finPartida, int &ordenJugador_1, int &ordenJugador_2, int ronda, int &gallina_suertuda_j1, int &gallina_suertuda_j2);

int verificador_de_desorden(string jugador_1, string jugador_2, string corraljugador_1[], string corraljugador_2[], int CARTAS_POR_MANO, string ganador);

int contador_de_puntos(string ganador, string jugador_1, string jugador_2, int dado_1, int dado_2, int cartas_desordenadas, bool jugador_1_paso_turno, bool jugador_2_paso_turno, bool le_robaron_al_1, bool le_robaron_al_2, int gallina_suertuda_j1, int gallina_suertuda_j2);

void asignacion_maxima_puntuacion(int puntuacionFinal, string ganador, int &maximaPuntuacion, string &maximoGanador);




/** pvp ----------------------------------------------------------------------------------------------------------------- **/
void inicioPartida(int &maximaPuntuacion, string &maximoGanador, string &jugador_1, string &jugador_2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], int CARTAS_POR_MANO){

    int ronda = 0, dado, cartas_desordenadas = 0, puntuacionFinal = 0;
    bool finPartida = false;
    char confirmar;
    string turno, ganador;

    int dado_1, dado_2; // guarda el ultimo valor del dado de cada jugador

    bool jugador_1_paso_turno = false, jugador_2_paso_turno = false; // verifican si dicho jugador paso de turno

    bool le_robaron_al_1 = false, le_robaron_al_2 = false; // verifica si a dicho jugador le robaron una carta

    iniciador_cartas_bloqueadas(cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2);

    int ordenJugador_1 = 0;
    int ordenJugador_2 = 0;

    int gallina_suertuda_j1 = 0, gallina_suertuda_j2 = 0;



    while(!finPartida){

        // la "ronda 0" es una forma subjetiva de usar el contador,
        // para que en primera instancia pida los nombres de los jugadores
        if (ronda == 0){
            do {
                cout << "\tCLUTCH" << endl;
                cout << "---------------------------------------------------------------------------------------" << endl;

                cout << "Antes de comenzar debe registrar sus nombres: " << endl;

                // inicia el jugador 1 ingresando su nombre
                cout << endl;
                cout << "jugador 1, ingrese su nombre: ";
                cin >> jugador_1;
                cout << endl;

                // continua el jugador 2 ingresando su nombre
                cout << endl;
                cout << "jugador 2, ingrese su nombre: ";
                cin >> jugador_2;
                cout << endl;

                cout << "confirmar nombres" << endl;
                cout << "S - si\nN - no" << endl;
                cin >> confirmar;
                while(confirmar != 'N' && confirmar != 'n' && confirmar != 'S' && confirmar != 's'){
                    cout << "ERROR, INGRESE UNA CONFIRMACION VALIDA" << endl;
                    cin >> confirmar;
                }

            } while (confirmar == 'N' || confirmar == 'n');

            cout << "---------------------------------------------------------------------------------------" << endl;


            cout << system("cls");

        // cuando el contador esta en 1, primera ronda, se reparten las cartas, por unica vez, y luego
        // se desarrolla el juego en base a la logica de los dados
        } else if (ronda == 1){
            cout << "\tCLUTCH" << endl;
            cout << "---------------------------------------------------------------------------------------" << endl;

            cout << "RONDA #" << ronda << endl;
            cout << jugador_1 << "  VS  " << jugador_2 << endl;
            cout << endl << "SE REPARTEN LAS CARTAS PARA CADA JUGADOR!!" << endl;


            // se asignan las cartas al primer jugador
            repatir_cartas(baraja_cartas_muestra, baraja_cartas_disponibles, corralJugador_1);

            cout << jugador_1 << ":" << endl;
            for (int x = 0; x < 5; x++){
                cout << "\t" << corralJugador_1[x] << " " << endl;
            }


            cout << " " << endl;


            // se asignan las cartas al segundo jugador
            repatir_cartas(baraja_cartas_muestra, baraja_cartas_disponibles, corralJugador_2);

            cout << jugador_2 << ":" << endl;
            for (int x = 0; x < 5; x++){
                cout << "\t" << corralJugador_2[x] << " " << endl;
            }

            cout << "---------------------------------------------------------------------------------------" << endl;

            verificador_de_orden(jugador_1, jugador_2, corralJugador_1, corralJugador_2, CARTAS_POR_MANO, ganador, finPartida, ordenJugador_1, ordenJugador_2, ronda, gallina_suertuda_j1, gallina_suertuda_j2);



            turno = quien_inicia(jugador_1, jugador_2, corralJugador_1, corralJugador_2);


            cout << system("pause");
            cout << system("cls");

        } else {
            cout << "\tCLUTCH" << endl;
            cout << "---------------------------------------------------------------------------------------" << endl;

            cout << "RONDA #" << (ronda) << endl;
            cout << endl;
            cout << jugador_1 << "  VS  " << jugador_2 << endl;
            cout << endl;

            if (turno == jugador_1){


                cout << "TURNO DE " << jugador_1 << endl;
                cout << endl;

                cout << jugador_1 << ":" << endl;
                for (int x = 0; x < 5; x++){
                    cout << "\t" << corralJugador_1[x] << " " << endl;
                }
                cout << endl;

                cout << jugador_2 << ":" << endl;
                for (int x = 0; x < 5; x++){
                    cout << "\t" << corralJugador_2[x] << " " << endl;
                }
                cout << endl;


                verificador_de_orden(jugador_1, jugador_2, corralJugador_1, corralJugador_2, CARTAS_POR_MANO, ganador, finPartida, ordenJugador_1, ordenJugador_2, ronda, gallina_suertuda_j1, gallina_suertuda_j2);


                if (!finPartida){
                    // funcion de tirar dados

                    dado = tirada_de_dados(turno);
                    dado_1 = dado;


                    // llamada a la funcion de los dados

                    acciones_del_dado(dado, turno, jugador_1, jugador_2, corralJugador_1, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);
                }


                // si el que inicio es el jugador 2, se define que el siguiente turno sera
                // del jugador 1
                turno = jugador_2;

            } else {

                cout << "TURNO DE " << jugador_2 << endl;
                cout << endl;

                cout << jugador_2 << ":" << endl;
                for (int x = 0; x < 5; x++){
                    cout << "\t" << corralJugador_2[x] << " " << endl;
                }
                cout << endl;

                cout << jugador_1 << ":" << endl;
                for (int x = 0; x < 5; x++){
                    cout << "\t" << corralJugador_1[x] << " " << endl;
                }
                cout << endl;


                verificador_de_orden(jugador_1, jugador_2, corralJugador_1, corralJugador_2, CARTAS_POR_MANO, ganador, finPartida, ordenJugador_1, ordenJugador_2, ronda, gallina_suertuda_j1, gallina_suertuda_j2);


                if (!finPartida){
                    // funcion de tirar dados

                    dado = tirada_de_dados(turno);
                    dado_2 = dado;

                    // llamada a la funcion de los dados

                    acciones_del_dado(dado, turno, jugador_1, jugador_2, corralJugador_1, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);
                }


                // si el que inicio es el jugador 2, se define que el siguiente turno sera
                // del jugador 1
                turno = jugador_1;

            }

            cout << "---------------------------------------------------------------------------------------" << endl;


        }

        ronda++;

    }

    cartas_desordenadas = verificador_de_desorden(jugador_1, jugador_2, corralJugador_1, corralJugador_2, CARTAS_POR_MANO, ganador);

    puntuacionFinal = contador_de_puntos(ganador, jugador_1, jugador_2, dado_1, dado_2, cartas_desordenadas, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2, gallina_suertuda_j1, gallina_suertuda_j2);

    if (puntuacionFinal > maximaPuntuacion){

        asignacion_maxima_puntuacion(puntuacionFinal, ganador, maximaPuntuacion, maximoGanador);

    }



}


/** estadisticas -----------------------------------------------------------------------------------------------------------------**/
void estadisticas(int maxPuntuacion, string maxGanador) {

    cout << "\tmejor puntuacion: " << maxPuntuacion << " " << maxGanador << endl;

    cout << "---------------------------------------------------------------------------------------" << endl;
}


/** creditos ----------------------------------------------------------------------------------------------------------------- **/

void creditos() {
    cout << "CREDITOS" << endl;
    cout << "---------------------------------------------------------------------------------------" << endl;
    cout << endl;
    cout << "\t-BARRIENTOS ABRIL" << endl;
    cout << "\t-DIAZ MARCELO" << endl;
    cout << "\t-PIRELLI BRAIAN" << endl;
    cout << "\t-SEQUEA ASDRUBAL" << endl;
    cout << endl;
    cout << "---------------------------------------------------------------------------------------" << endl;
}


/** tirada de dados ----------------------------------------------------------------------------------------------------------------- **/
int tirada_de_dados(string turno){

    int dado = 1 + rand()%(6);

    cout << "EL JUGADOR " << turno << " AGARRO Y TIRO EL DADO" << endl;
    cout << system("pause");
    cout << system("cls");
    cout << "SACO EL DADO: " << endl;
    cout << endl;

    switch (dado){
    case 1:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|     x     |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 2:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|  x        |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|        x  |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 3:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t| x         |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|     x     |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|          x|" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 4:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 5:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|     x     |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 6:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    }

    cout << system("pause");
    cout << system("cls");

    return dado;
}


/** carga de matrices -----------------------------------------------------------------------------------------------------------**/

void preparacion_barajas(string baraja_cartas_muestra[][4], bool baraja_cartas_disponibles[][4]) {

    const int TIPOS = 5;
    const int PALOS = 4;

    const string nombresCartas[] = {"10", "J", "Q", "K", "A"};
    const string nombresPalos[] = {"corazones", "picas", "diamantes", "trebol"};

    for (int x = 0; x < TIPOS; x++) {
        for (int y = 0; y < PALOS; y++) {
            baraja_cartas_muestra[x][y] = nombresCartas[x] + " " + nombresPalos[y];

            baraja_cartas_disponibles[x][y] = true;
        }
    }
}


/** reparticion de cartas ---------------------------------------------------------------------------------------------------------**/

void repatir_cartas(string baraja_cartas_muestra[][4], bool baraja_cartas_disponibles[][4], string corral[]){

    srand(time(NULL));

    int manoDeCartas = 5;
    int indiceCarta;
    int indicePalo;

    for (int x = 0; x < manoDeCartas; x++){
        indiceCarta = rand()%(5); // CAMBIE LOS INDICES YA QUE DE LA FORMA QUE ESTABAN ESCRITOS
        indicePalo = rand()%(4);  // ANTES, NO SE ANALIZABA EL "AS"

        // pregunto si en la posicion del indice random "carta" y random "palo", esta disponible
        if (baraja_cartas_disponibles[indiceCarta][indicePalo] == true){

            // si esta, se asigna al "corral" el valor que tiene almacenado la matriz "muestra",
            // y la matriz "disponible" se pone en false
            corral[x] = baraja_cartas_muestra[indiceCarta][indicePalo];
            baraja_cartas_disponibles[indiceCarta][indicePalo] = false;

        } else {
            // en caso de no estar disponible esa carta se generan dos indices nuevos hasta que si este disponible
            while (baraja_cartas_disponibles[indiceCarta][indicePalo] == false){

                indiceCarta = rand()%(5); // CAMBIE LOS INDICES PARA QUE SE PUEDA RECORRER DE FORMA MAS EFICAZ
                indicePalo = rand()%(4);  // LA MATRIZ

            }
            // una vez este disponible se asignan al "corral" y se asigna false a la matriz "disponible"
            corral[x] = baraja_cartas_muestra[indiceCarta][indicePalo];
            baraja_cartas_disponibles[indiceCarta][indicePalo] = false;
        }

        // el proceso debe repetirse 5 veces ya que el "corral" o mano de jugador se compone de 5 cartas :)
    }
}


/** quien comienza la partida ---------------------------------------------------------------------------------------------------------**/

string quien_inicia(string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[]){
    int cantidad_j1 = 0, cantidad_j2 = 0;
    for (int x = 0; x < CARTAS_POR_MANO; x++){
        if (corralJugador_1[x] == "A corazones" || corralJugador_1[x] == "A picas" || corralJugador_1[x] == "A diamantes" || corralJugador_1[x] == "A trebol"){
            cantidad_j1++;
        }
    }

    for (int x = 0; x < CARTAS_POR_MANO; x++){
        if (corralJugador_2[x] == "A corazones" || corralJugador_2[x] == "A picas" || corralJugador_2[x] == "A diamantes" || corralJugador_2[x] == "A trebol"){
            cantidad_j2++;
        }
    }

    if (cantidad_j1 == cantidad_j2){
        cantidad_j1 = 0, cantidad_j2 = 0;
        for (int x = 0; x < CARTAS_POR_MANO; x++){
            if (corralJugador_1[x] == "K corazones" || corralJugador_1[x] == "K picas" || corralJugador_1[x] == "K diamantes" || corralJugador_1[x] == "K trebol"){
                cantidad_j1++;
            }
        }

        for (int x = 0; x < CARTAS_POR_MANO; x++){
            if (corralJugador_2[x] == "K corazones" || corralJugador_2[x] == "K picas" || corralJugador_2[x] == "K diamantes" || corralJugador_2[x] == "K trebol"){
                cantidad_j2++;
            }
        }


        if (cantidad_j1 == cantidad_j2){
            cantidad_j1 = 0, cantidad_j2 = 0;
            for (int x = 0; x < CARTAS_POR_MANO; x++){
                if (corralJugador_1[x] == "Q corazones" || corralJugador_1[x] == "Q picas" || corralJugador_1[x] == "Q diamantes" || corralJugador_1[x] == "Q trebol"){
                    cantidad_j1++;
                }
            }

            for (int x = 0; x < CARTAS_POR_MANO; x++){
                if (corralJugador_2[x] == "Q corazones" || corralJugador_2[x] == "Q picas" || corralJugador_2[x] == "Q diamantes" || corralJugador_2[x] == "Q trebol"){
                    cantidad_j2++;
                }
            }

            if (cantidad_j1 == cantidad_j2){
                cantidad_j1 = 0, cantidad_j2 = 0;
                for (int x = 0; x < CARTAS_POR_MANO; x++){
                    if (corralJugador_1[x] == "J corazones" || corralJugador_1[x] == "J picas" || corralJugador_1[x] == "J diamantes" || corralJugador_1[x] == "J trebol"){
                        cantidad_j1++;
                    }
                }

                for (int x = 0; x < CARTAS_POR_MANO; x++){
                    if (corralJugador_2[x] == "J corazones" || corralJugador_2[x] == "J picas" || corralJugador_2[x] == "J diamantes" || corralJugador_2[x] == "J trebol"){
                        cantidad_j2++;
                    }
                }

                if (cantidad_j1 == cantidad_j2){
                    cantidad_j1 = 0, cantidad_j2 = 0;
                    for (int x = 0; x < CARTAS_POR_MANO; x++){
                        if (corralJugador_1[x] == "10 corazones" || corralJugador_1[x] == "10 picas" || corralJugador_1[x] == "10 diamantes" || corralJugador_1[x] == "10 trebol"){
                            cantidad_j1++;
                        }
                    }

                    for (int x = 0; x < CARTAS_POR_MANO; x++){
                        if (corralJugador_2[x] == "10 corazones" || corralJugador_2[x] == "10 picas" || corralJugador_2[x] == "10 diamantes" || corralJugador_2[x] == "10 trebol"){
                            cantidad_j2++;
                        }
                    }

                    if (cantidad_j1 > cantidad_j2){
                        return jugador1;
                    } else {
                        return jugador2;
                    }
                } else if (cantidad_j1 > cantidad_j2){
                    return jugador1;
                } else {
                    return jugador2;
                }

            } else if (cantidad_j1 > cantidad_j2){
                return jugador1;
            } else {
                return jugador2;
            }

        } else if (cantidad_j1 > cantidad_j2){
            return jugador1;
        } else {
            return jugador2;
        }

    } else if (cantidad_j1 > cantidad_j2){
        return jugador1;
    } else {
        return jugador2;
    }
}


/** iniciador de cartas bloqueadas ---------------------------------------------------------------------------------------------------------**/

void iniciador_cartas_bloqueadas(bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[]){

    for (int x = 0; x < CARTAS_POR_MANO; x++){
        cartas_bloqueadas_jugador1[x] = false;
        cartas_bloqueadas_jugador2[x] = false;
    }

}


/** acciones del dado -----------------------------------------------------------------------------------------------------------------------*/

void acciones_del_dado(int dado, string turno, string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], bool &jugador_1_paso_turno, bool &jugador_2_paso_turno, bool &le_robaron_al_1, bool &le_robaron_al_2){


    switch(dado){
        case 1:
            if (turno == jugador1){
                accion_1(turno, corralJugador_1, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1);
            } else {
                accion_1(turno, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador2);
            }
            cout << system("pause");
            cout << system("cls");
            break;
        case 2:
            if (turno == jugador1){
                accion_2(turno, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador2);
            } else {
                accion_2(turno, corralJugador_1, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1);
            }
            cout << system("pause");
            cout << system("cls");
            break;
        case 3:
            if (turno == jugador1){
                accion_3(turno, corralJugador_1, corralJugador_2, cartas_bloqueadas_jugador2, cartas_bloqueadas_jugador1, le_robaron_al_1);
            } else {
                accion_3(turno, corralJugador_2, corralJugador_1, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, le_robaron_al_2);
            }
            cout << system("pause");
            cout << system("cls");
            break;
        case 4:
            if (turno == jugador1){
                accion_4(turno, corralJugador_1);
            } else {
                accion_4(turno, corralJugador_2);
            }
            cout << system("pause");
            cout << system("cls");
            break;
        case 5:
            if (turno == jugador1){
                accion_5(turno, corralJugador_1, cartas_bloqueadas_jugador1);
            } else {
                accion_5(turno, corralJugador_2, cartas_bloqueadas_jugador2);
            }
            cout << system("pause");
            cout << system("cls");
            break;
        case 6:
            if (turno == jugador1){

                accion_6(turno, jugador1, jugador2, corralJugador_1, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);
            } else {
                accion_6(turno, jugador1, jugador2, corralJugador_1, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);
            }
            cout << system("pause");
            cout << system("cls");
            break;
    }
}


/** accion del dado 1 (dejar una propia y levantar una nueva)------------------------------------------------------------------------------------------------------------------------*/

void accion_1(string turno, string corral_propio[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas[]){



    int seleccion_propio, seleccion_tipo, seleccion_palo;
    string temp; // variable temporal auxiliar

    cout << "turno del jugador " << turno << endl << endl;

    for (int x = 0; x < 5; x++){
        cout << "\t" << corral_propio[x] << " " << endl;
    }
    cout << endl;
    cout << "ingrese una carta propia, para enviar al mazo y levantar una nueva" << endl;
    // se llama a la funcion para verificar
    // que no se ingrese una letra en el indice
    seleccion_propio = verificador_de_indices();


    /*
    codigo anterior
    // Obtener la selección del usuario para la carta del propio corral (1-5)
    cout << "Elija una carta de su propio corral (1-5) \npara mandarla al mazo y levantar una nueva: ";
    cin >> seleccion_propio;

    // VERIFICA QUE LOS INDICES SEAN CORRECTOS
    while (seleccion_propio < 1 || seleccion_propio > 5){
        cout << "ERROR, SELECCION INVALIDA, INGRESE OTRAS CARTAS" << endl;
        cin >> seleccion_propio;
    }

    seleccion_propio--; // Convertir a índice de arreglo (0-4)

    */



    // Obtener una carta del mazo (simulado aquí como una carta aleatoria)
    seleccion_tipo = rand() % TIPOS_CARTAS; // como usamos una matriz, deben ser dos indices decidi probar modificando la accion
    seleccion_palo = rand() % PALOS;        // del dado usando el mismo metodo que usamos para repartir las cartas aleatoriamente


    // pregunta si la carta que el jugador eligio de su mano esta bloqueada,
    // si es verdad la desbloquea
    if (cartas_bloqueadas[seleccion_propio] == true){
        cartas_bloqueadas[seleccion_propio] = false;
    }


    temp = corral_propio[seleccion_propio];

    if (baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] == true){ // primeramente verifica que la carta este disponible

        // Realiza el intercambio de cartas si la carta esta disponible

        for (int x = 0; x < TIPOS_CARTAS; x++){
            for (int y = 0; y < PALOS; y++){

                // aca lo que hace es buscar la carta que selecciono el jugador
                // en la baraja de muestra, una vez que la encuentra
                // usa los indices de esa carta (alojados en la "baraja muestra",
                // usa ese indice en la "baraja disponibles", y convierte la carta a disponible
                if (temp == baraja_cartas_muestra[x][y]){
                    baraja_cartas_disponibles[x][y] = true;
                }
            }
        }
        // aca, en base a la carta disponible, reemplaza la carta de "corral propio"
        // con una aleatoria obtenida de la "baraja muestra".
        corral_propio[seleccion_propio] = baraja_cartas_muestra[seleccion_tipo][seleccion_palo];

        // y aca, lo que hace es poner, en false la carta asi ya no esta disponible para su eleccion.
        baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] = false;

    } else {
        // en caso de no estar disponible genera indices
        // hasta toparse con una posicion de carta disponible
        while (baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] == false){
            seleccion_tipo = rand() % TIPOS_CARTAS;
            seleccion_palo = rand() % PALOS;
        }

        // Realizar el intercambio de cartas

        for (int x = 0; x < TIPOS_CARTAS; x++){
            for (int y = 0; y < PALOS; y++){
                if (temp == baraja_cartas_muestra[x][y]){
                    baraja_cartas_disponibles[x][y] = true;
                }
            }
        }
        corral_propio[seleccion_propio] = baraja_cartas_muestra[seleccion_tipo][seleccion_palo];

        baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] = false;
    }
}


/** accion del dado 2 (dejar una del rival y levantar una nueva)------------------------------------------------------------------------------------------------------------------------*/

void accion_2(string turno, string corral_contrario[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas[]){
    int seleccion_contrario, seleccion_tipo, seleccion_palo;
    string temp; // variables temporal / auxiliar
    cout << "turno del jugador " << turno << endl << endl;


    for (int x = 0; x < 5; x++){
        cout << "\t" << corral_contrario[x] << " " << endl;
    }
    cout << endl;


    // Obtener la selección del usuario para la carta del corral del contrario (1-5)
    cout << "Elija una carta del corral del contrario (1-5) \npara mandarla al mazo y levantar una nueva: ";

    seleccion_contrario = verificador_de_indices();

    // verifica que la carta en esa seleccion no este bloqueada por su dueño
    while (cartas_bloqueadas[seleccion_contrario] == true){

        cout << "no se puede seleccionar esta carta, el dueño la bloqueo" << endl;
        seleccion_contrario = verificador_de_indices();
    }

    // Obtener una carta del mazo (simulado aquí como una carta aleatoria)
    seleccion_tipo = rand() % TIPOS_CARTAS;
    seleccion_palo = rand() % PALOS;




    if (baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] == true){ // primeramente verifica que la carta este disponible

        // Realiza el intercambio de cartas si la carta esta disponible

        for (int x = 0; x < TIPOS_CARTAS; x++){
            for (int y = 0; y < PALOS; y++){

                // aca lo que hace es buscar la carta que selecciono el jugador
                // en la baraja de muestra, una vez que la encuentra
                // usa los indices de esa carta (alojados en la "baraja muestra",
                // usa ese indice en la "baraja disponibles", y convierte la carta a disponible
                if (temp == baraja_cartas_muestra[x][y]){
                    baraja_cartas_disponibles[x][y] = true;
                }
            }
        }
        // aca, en base a la carta disponible, reemplaza la carta de "corral propio"
        // con una aleatoria obtenida de la "baraja muestra".
        corral_contrario[seleccion_contrario] = baraja_cartas_muestra[seleccion_tipo][seleccion_palo];

        // y aca, lo que hace es poner, en false la carta asi ya no esta disponible para su eleccion.
        baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] = false;

    } else {
        // en caso de no estar disponible genera indices
        // hasta toparse con una posicion de carta disponible
        while (baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] == false){
            seleccion_tipo = rand() % TIPOS_CARTAS;
            seleccion_palo = rand() % PALOS;
        }

        // Realizar el intercambio de cartas

        for (int x = 0; x < TIPOS_CARTAS; x++){
            for (int y = 0; y < PALOS; y++){
                if (temp == baraja_cartas_muestra[x][y]){
                    baraja_cartas_disponibles[x][y] = true;
                }
            }
        }
        corral_contrario[seleccion_contrario] = baraja_cartas_muestra[seleccion_tipo][seleccion_palo];

        baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] = false;
    }
}


/** accion del dado 3 (intercambiar una carta propia con una del rival)------------------------------------------------------------------------------------------------------------------------*/

void accion_3(string turno, string corral_propio[], string corral_contrario[], bool cartas_bloqueadas_contrario[], bool cartas_bloqueadas_propias[], bool &le_robaron){
    int seleccion_contrario, seleccion_propio;
    string temp; // variables temporal / auxiliar

    le_robaron = true;

    cout << "turno del jugador " << turno << endl << endl;


    cout << "INTERCAMBIE CARTA PROPIA POR UNA DEL CONTRARIO" << endl << endl;

    cout << "(SI SU CARTA PROPIA ELEGIDA, ESTA BLOQUEADA)" << endl;
    cout << "(SE DESBLOQUEARA E INTERCAMBIARA)" << endl << endl;


    // muestra los mazos para hacer mas interactivo
    cout << "corral contrario:" << endl;
    for (int x = 0; x < 5; x++){
        cout << "\t" << corral_contrario[x] << " " << endl;
    }
    cout << endl;


    cout << "corral propio:" << endl;
    for (int x = 0; x < 5; x++){
        cout << "\t" << corral_propio[x] << " " << endl;
    }
    cout << endl;

    ///////////////////////////////////////////////////////////////////


    // Obtener la selección del usuario para la carta del corral del contrario (1-5)
    cout << "Elija una carta del corral del contrario (1-5): ";

    seleccion_contrario = verificador_de_indices();


    // verifica que la carta en esa seleccion no este bloqueada por su dueño
    while (cartas_bloqueadas_contrario[seleccion_contrario] == true){

        cout << "no se puede seleccionar esta carta, el duenio la bloqueo" << endl;

        seleccion_contrario = verificador_de_indices();

    }


    // Obtener la selección del usuario para la carta del corral del contrario (1-5)
    cout << "Elija una carta del corral propio (1-5): ";
    seleccion_propio = verificador_de_indices();



    // verifica que la carta en esa seleccion bloqueada por si mismo
    // si lo esta, la desbloquea e intercambia
    if (cartas_bloqueadas_propias[seleccion_propio] == true){

        cartas_bloqueadas_propias[seleccion_propio] = false;

    }



    // Realizar el intercambio de cartas
    temp = corral_propio[seleccion_propio];
    corral_propio[seleccion_propio] = corral_contrario[seleccion_contrario];
    corral_contrario[seleccion_contrario] = temp;
}


/** accion del dado 4 (intercambiar las posiciones de cartas propias)------------------------------------------------------------------------------------------------------------------------*/

void accion_4(string turno, string corral_propio[]){
    int primera_seleccion, segunda_seleccion;
    string temp; // VARIABLE TEMPORAL / AUXILIAR
    cout << "turno del jugador " << turno << endl << endl;


    for (int x = 0; x < 5; x++){
        cout << "\t" << corral_propio[x] << " " << endl;
    }
    cout << endl;



    // Obtener las selecciones del usuario para las cartas del propio corral (1-5)
    cout << "Elija dos cartas de su propio corral (1-5), separadas por un espacio: " << endl;

    cout << "primera carta: ";
    primera_seleccion = verificador_de_indices();
    cout << "segunda carta: ";
    segunda_seleccion = verificador_de_indices();



    // Realizar el intercambio de cartas
    // Realizar el intercambio de cartas
    temp = corral_propio[primera_seleccion];
    corral_propio[primera_seleccion] = corral_propio[segunda_seleccion];
    corral_propio[segunda_seleccion] = temp;
}


/** accion del dado 5 (elegir una carta propia para bloquear)------------------------------------------------------------------------------------------------------------------------*/

void accion_5(string turno, string corral_propio[], bool cartas_bloqueadas[]) {
    int seleccion;
    cout << "turno del jugador " << turno << endl << endl;


    for (int x = 0; x < 5; x++){
        cout << "\t" << corral_propio[x] << " " << endl;
    }
    cout << endl;


    // Obtener la selección del usuario para la carta del propio corral (1-5)
    cout << "Elija una carta de su propio corral (1-5) para bloquear: " << endl;
    cout << "(considere que si la carta ya se encuentra bloqueada, se desbloqueara)" << endl;

    seleccion = verificador_de_indices();
    if (cartas_bloqueadas[seleccion] == true){
        cartas_bloqueadas[seleccion] = false;
    }

    // Marcar la carta como bloqueada
    cartas_bloqueadas[seleccion] = true;
}


/** accion del dado 6 ------------------------------------------------------------------------------------------------------------------------*/

void accion_6(string turno, string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], bool &jugador_1_paso_turno, bool &jugador_2_paso_turno, bool &le_robaron_al_1, bool &le_robaron_al_2){
    char eleccion;

    cout << "JUGADOR " << turno << " ELIJA UNA OPCION DE LAS DISPONIBLES" << endl << endl;

    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      1    |                 DEJAR UNA CARTA PROPIA Y LEVANTAR UNA NUEVA           |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      2    |               DEJAR UNA CARTA DEL RIVAL Y LEVANTAR UNA NUEVA          |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      3    |               INTERCAMBIE UNA CARTA DEL RIVAL CON UNA PROPIA          |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      4    |         ELIJA 2 CARTAS DEL CORRAL PROPIO E INTERCAMBIAR SUS LUGARES   |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      5    |              SELECCIONAR UNA CARTA DEL CORRAL PROPIO PARA BLOQUEAR    |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      6    |                                 PASAR EL TURNO                        |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;

    cin >> eleccion;

    while(eleccion != '1' && eleccion != '2' && eleccion != '3'&& eleccion != '4'&& eleccion != '5'&& eleccion != '6'){

        cout << "ERROR, LA ELECCION ES INVALIDA >:C" << endl;
        cout << "VUELVA A INGRESAR SU ELECCION" << endl;

        cin >> eleccion;
        cout << system("pause");
        cout << system("cls");
    }


    switch (eleccion){

        case '1':
            if (turno == jugador1){
                accion_1(turno, corralJugador_1, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1);
            } else {
                accion_1(turno, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador2);
            }
            cout << system("pause");
            cout << system("cls");
            break;

        case '2':
            if (turno == jugador1){
                accion_2(turno, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador2);
            } else {
                accion_2(turno, corralJugador_1, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1);
            }
            cout << system("pause");
            cout << system("cls");
            break;

        case '3':
            if (turno == jugador1){
                accion_3(turno, corralJugador_1, corralJugador_2, cartas_bloqueadas_jugador2, cartas_bloqueadas_jugador1, le_robaron_al_1);
            } else {
                accion_3(turno, corralJugador_2, corralJugador_1, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, le_robaron_al_2);
            }
            cout << system("pause");
            cout << system("cls");
            break;

        case '4':
            if (turno == jugador1){
                accion_4(turno, corralJugador_1);
            } else {
                accion_4(turno, corralJugador_2);
            }
            cout << system("pause");
            cout << system("cls");
            break;

        case '5':
            if (turno == jugador1){
                accion_5(turno, corralJugador_1, cartas_bloqueadas_jugador1);
            } else {
                accion_5(turno, corralJugador_2, cartas_bloqueadas_jugador2);
            }
            cout << system("pause");
            cout << system("cls");
            break;

        case '6':
            if (turno == jugador1){
                cout << "EL JUGADOR " << turno << " HA ELEGIDO LA OPCION DE PASAR EL TURNO" << endl;
                jugador_1_paso_turno = true;
            } else {
                cout << "EL JUGADOR " << turno << " HA ELEGIDO LA OPCION DE PASAR EL TURNO" << endl;
                jugador_2_paso_turno = true;
            }
            cout << system("pause");
            cout << system("cls");
            break;
    }
}


/** verificador de indices ------------------------------------------------------------------------------------------------------------------------*/


int verificador_de_indices(){
	int indice;
	char caracter;

    // primeramenete, se ingresa un numero
    // se hace en tipo CHAR, ya que la verificacion
    // se realiza en ASCII
	cin >> caracter;


    // en este punto realiza una comparacion entre el valor del caracter(char)
    // convertido a entero(int), y pregunta si estan dentro del rango valido
    //     49 - 1
    //     50 - 2
    //     51 - 3
    //     52 - 4
    //     53 - 5
    // si el numero / caracter es valido, le resta su respectivo numero en ASCII
    // para convertirlo en indice, y lo retorna al flujo original

    if ((int)caracter > 48 && (int)caracter <54){

        indice = (int)caracter - 49;
        return indice;

    } else {

        // en caso de no estar en el rango valido
        // vuelve a pedir el ingreso del numero
        // hasta que este sea valido
        while ((int)caracter < 49 || (int)caracter >53){

            cout << "ingrese un numero correcto" << endl;
            cin >> caracter;

        }
        indice = (int)caracter - 49;
        return indice;

    }


}


/** verificador de orden de cada corral ------------------------------------------------------------------------------------------------------------------------*/


void verificador_de_orden(string jugador_1, string jugador_2, string corraljugador_1[], string corraljugador_2[], int CARTAS_POR_MANO, string &ganador, bool &finPartida, int &ordenJugador_1, int &ordenJugador_2, int ronda, int &gallina_suertuda_j1, int &gallina_suertuda_j2){

    const string barajaDiamante[] = {"10 diamantes", "J diamantes", "Q diamantes", "K diamantes", "A diamantes"};
    const string barajaCorazon[] = {"10 corazones", "J corazones", "Q corazones", "K corazones", "A corazones"};
    const string barajaPicas[] = {"10 picas", "J picas", "Q picas", "K picas", "A picas"};
    const string barajaTrebol[] = {"10 trebol", "J trebol", "Q trebol", "K trebol", "A trebol"};

    ordenJugador_1 = 0;
    ordenJugador_2 = 0;


    for (int x = 0; x < CARTAS_POR_MANO; x++){
        if (corraljugador_1[x] == barajaDiamante[x] || corraljugador_1[x] == barajaCorazon[x]|| corraljugador_1[x] == barajaPicas[x] || corraljugador_1[x] == barajaTrebol[x]){
            ordenJugador_1++;
        }

        if (corraljugador_2[x] == barajaDiamante[x] || corraljugador_2[x] == barajaCorazon[x]|| corraljugador_2[x] == barajaPicas[x] || corraljugador_2[x] == barajaTrebol[x]){
            ordenJugador_2++;
        }
    }


    if (ordenJugador_1 == 5){

        cout << "FELICIDADES JUGADOR " << jugador_1 << " SU CORRAL ESTA ORDENADO" << endl;
        ganador = jugador_1;
        cout << system("pause");
        cout << system("cls");
        finPartida = true;

    } else if (ordenJugador_2 == 5){

        cout << "FELICIDADES JUGADOR " << jugador_2 << " SU CORRAL ESTA ORDENADO" << endl;
        ganador = jugador_2;
        cout << system("pause");
        cout << system("cls");
        finPartida = true;

    }

    if (ronda == 1){
        gallina_suertuda_j1 = ordenJugador_1 * 5;
        gallina_suertuda_j2 = ordenJugador_2 * 5;
    }



}


/** verificador de desorden del corral perdedor ------------------------------------------------------------------------------------------------------------------------*/


int verificador_de_desorden(string jugador_1, string jugador_2, string corraljugador_1[], string corraljugador_2[], int CARTAS_POR_MANO, string ganador){

    const string barajaDiamante[5] = {"10 diamante", "J diamante", "Q diamante", "K diamante", "A diamante"};
    const string barajaCorazon[5] = {"10 corazon", "J corazon", "Q corazon", "K corazon", "A corazon"};
    const string barajaPicas[5] = {"10 picas", "J picas", "Q picas", "K picas", "A picas"};
    const string barajaTrebol[5] = {"10 trebol", "J trebol", "Q trebol", "K trebol", "A trebol"};

    int desordenJugador = 0;


    if (ganador == jugador_1){

        for (int x = 0; x < CARTAS_POR_MANO; x++){
            if (corraljugador_2[x] != barajaDiamante[x] && corraljugador_2[x] != barajaCorazon[x] && corraljugador_2[x] != barajaPicas[x] && corraljugador_2[x] != barajaTrebol[x]){
                desordenJugador ++;
            }
        }

    } else {

        for (int x = 0; x < CARTAS_POR_MANO; x++){
            if (corraljugador_1[x] != barajaDiamante[x] && corraljugador_1[x] != barajaCorazon[x] && corraljugador_1[x] != barajaPicas[x] && corraljugador_1[x] != barajaTrebol[x]){
                desordenJugador ++;
            }
        }

    }

    return desordenJugador;
}


/** contador de puntos ------------------------------------------------------------------------------------------------------------------------*/


int contador_de_puntos(string ganador, string jugador_1, string jugador_2, int dado_1, int dado_2, int cartas_desordenadas, bool jugador_1_paso_turno, bool jugador_2_paso_turno, bool le_robaron_al_1, bool le_robaron_al_2, int gallina_suertuda_j1, int gallina_suertuda_j2){

    int puntuacionFinal = 15;


    cout << "-------------------------------------------------------------------------------------" << endl;

    cout << "\tHITO \t\t\t\t\t\t\t     " << ganador << endl;

    cout << "-------------------------------------------------------------------------------------" << endl << endl;

    cout << "GANAR LA PARTIDA \t\t\t\t\t\t\t +15 PDV" << endl;


    if (ganador == jugador_1){

        if (dado_1 == 3){
            puntuacionFinal += 10;
            cout << "ROBO LA ULTIMA CARTA AL JUGADOR RIVAL: \t\t\t\t\t +10 PDV" << endl;
        } else{
            cout << "ROBO LA ULTIMA CARTA AL JUGADOR RIVAL: \t\t\t\t\t +0 PDV" << endl;
        }

        puntuacionFinal += (cartas_desordenadas * 5);
        cout << "CARTAS MAL UBICADAS DEL RIVAL x" << cartas_desordenadas << "\t\t\t\t\t+" << (cartas_desordenadas*5) << " PDV" << endl;

        // en estos casos las declaraciones se encuentran negadas ya que, las variables se declaran en false
        // por logica (si no te robaron una carta/no pasaste de turno) estan en false
        // si si te robaron / pasaste de turno, se pone en true
        // la pregunta es si no te robaron / pasaste de turno, debe sumar, pero si es asi la variable esta en false
        // entonces, para que de verdadero debe ser negada
        if (!jugador_1_paso_turno){
            puntuacionFinal += 10;
            cout << "SIN PASAR TURNO \t\t\t\t\t\t\t+10 PDV" << endl;
        } else {
            cout << "SIN PASAR TURNO \t\t\t\t\t\t\t+0 PDV" << endl;
        }

        if (!le_robaron_al_1){
            puntuacionFinal += 5;
            cout << "SIN HABER SUFRIDO UN ROBO DEL RIVAL: \t\t\t\t\t +5 PDV" << endl;
        } else {
            cout << "SIN HABER SUFRIDO UN ROBO DEL RIVAL: \t\t\t\t\t +0 PDV" << endl;

        }

        puntuacionFinal += gallina_suertuda_j1;
        cout << "GALLINA SUERTUDA: " << gallina_suertuda_j1/5 << "\t\t\t\t\t +" << gallina_suertuda_j1 << " PDV" << endl;



    } else {

        if (dado_2 == 3){
            puntuacionFinal += 10;
            cout << "ROBO LA ULTIMA CARTA AL JUGADOR RIVAL: \t\t\t\t\t +10 PDV" << endl;
        } else {
            cout << "ROBO LA ULTIMA CARTA AL JUGADOR RIVAL: \t\t\t\t\t +0 PDV" << endl;
        }

        puntuacionFinal += cartas_desordenadas * 5;
        cout << "CARTAS MAL UBICADAS DEL RIVAL x" << cartas_desordenadas << "\t\t\t\t\t+" << (cartas_desordenadas*5) << " PDV" << endl;



        if (!jugador_2_paso_turno){
            puntuacionFinal += 10;
            cout << "SIN PASAR TURNO \t\t\t\t\t\t\t +10 PDV" << endl;
        } else {
            cout << "SIN PASAR TURNO \t\t\t\t\t\t\t +0 PDV" << endl;
        }


        if (!le_robaron_al_2){
            puntuacionFinal += 5;;
            cout << "SIN HABER SUFRIDO UN ROBO DEL RIVAL: \t\t\t\t\t +5 PDV" << endl;
        } else {
            cout << "SIN HABER SUFRIDO UN ROBO DEL RIVAL: \t\t\t\t\t +0 PDV" << endl;

        }

        puntuacionFinal += gallina_suertuda_j2;
        cout << "GALLINA SUERTUDA: " << gallina_suertuda_j2/5 << "\t\t\t\t\t\t\t +" << gallina_suertuda_j2 << " PDV" << endl;


    }
    cout << endl << "-----------------------------------------------------------------------------------" << endl;
    cout << "TOTAL \t\t\t\t\t\t\t\t\t" << puntuacionFinal << " PDV" << endl;

    return puntuacionFinal;
}


/** asignacion de maxima puntuacion ------------------------------------------------------------------------------------------------------------------------*/


void asignacion_maxima_puntuacion(int puntuacionFinal, string ganador, int &maximaPuntuacion, string &maximoGanador){

    maximoGanador = ganador;
    maximaPuntuacion = puntuacionFinal;

}
